#include <string>
#include <iostream>
#include <vector>
#include <queue>
#include <stdint.h>
#include <QDebug>
#include <bitset>
#include "crc.h"


itpp::bvec kvs_interleaver(itpp::bvec input, uint32_t rows, uint32_t cols) //input.size = rows * cols
{
    itpp::bmat inter_mat = itpp::zeros_b(rows, cols);
    itpp::bvec output = itpp::zeros_b(rows * cols);

    for (uint8_t i = 0; i < cols/2; i++)
        for (uint8_t j = 0; j < rows; j++)
            inter_mat(j, i*2 + 1) = input(rows * i + j);

    for (uint8_t i = 0; i < cols/2; i++)
        for (uint8_t j = 0; j < rows; j++)
            inter_mat(j, i*2) = input((rows * cols)/2 + rows * i + j);

    if (cols % 2 != 0){
        for (uint8_t j = 0; j < rows; j++)
            inter_mat(j, cols) = input(rows * (cols - 1) + j);
    }

    for (uint8_t i = 0; i < rows; i++)
        for (uint8_t j = 0; j < cols; j++)
            output(i * cols + j) = inter_mat(i, j);

    return output;
}

itpp::bvec kvs_deinterleaver(itpp::bvec input, uint32_t rows, uint32_t cols) //input.size = rows * cols
{
    itpp::bmat inter_mat = itpp::zeros_b(rows, cols);
    itpp::bvec output = itpp::zeros_b(rows * cols);

    for (uint8_t i = 0; i < rows; i++)
        for (uint8_t j = 0; j < cols; j++)
            inter_mat(i, j) = input(i * cols + j);

    for (uint8_t i = 0; i < cols/2; i++)
        for (uint8_t j = 0; j < rows; j++)
            output(rows * i + j) = inter_mat(j, i*2 + 1);

    for (uint8_t i = 0; i < cols/2; i++)
        for (uint8_t j = 0; j < rows; j++)
            output((rows * cols)/2 + rows * i + j) = inter_mat(j, i*2);

    if (cols % 2 != 0){
        for (uint8_t j = 0; j < rows; j++)
            output(rows * (cols - 1) + j) = inter_mat(j, cols);
    }

    return output;
}

int main()
{
    paramOFDM param112;
    paramOFDM param56;

    param112.fs = 8000.0; // Hz
    param112.deltaFreq = 25.641 / param112.fs;
    param112.freqShift = 0.0 / param112.fs;
    param112.firstChannel = 15;
    param112.numberOfChannels = 112;
    param112.pilotTone = 3333.3333 / param112.fs;
    param112.integrPeriodLength = 312;
    param112.cyclPrefLength = 48;
    param112.ofdmLength = param112.integrPeriodLength + param112.cyclPrefLength;

    param56.fs = 8000.0; // Hz
    param56.deltaFreq = 2 * 25.641 / param56.fs;
    param56.freqShift = 25.641 / param56.fs;
    param56.firstChannel = 15 / 2;
    param56.numberOfChannels = 112 / 2;
    param56.pilotTone = 3333.3333 / param56.fs;
    param56.integrPeriodLength = 312;
    param56.cyclPrefLength = 48;
    param56.ofdmLength = param56.integrPeriodLength + param56.cyclPrefLength;

    //Считывание исходной информации
    Convert conv;
    std::vector<uint8_t> inputDataBits = fromFileUC("decoded_bits.bin");
    std::vector<uint8_t> extra_bits = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01};
    inputDataBits.insert(inputDataBits.end(), extra_bits.begin(), extra_bits.end());
    std::cout << inputDataBits.size() << std::endl;
    toFile("dec_bytes.bin", conv.toSymbol(inputDataBits,8));
    itpp::bvec inputBits = itpp::zeros_b(inputDataBits.size());
    for (unsigned int i = 0; i < inputDataBits.size(); i++)
        if (inputDataBits[i] != 0x00) inputBits[i] = 1;
    qDebug() << "Input bits size: " << inputDataBits.size();

//    itpp::bvec extra_bits("0 0 0 0 0 1 1 1 0 1 0 0 1 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 1 0 0 1");
//    inputBits.ins(inputBits.size(), extra_bits);
//    std::cout << inputBits.size() << std::endl;
     std::vector<uint8_t> data;
     std::vector<uint8_t> data2;
/*     data = {
                0x00,  0x01,   0x91,   0x00,   0x00,   0x01,   0x89,  0x00,  0x53,  0x00,  0x00,  0x00,  0xE9,  0x00,
                0x61,  0x00,   0x5F,   0x4B,   0x49,   0x30,   0x30,  0x31,  0x30,  0x31,  0x2E,  0x6A,  0x6B,  0x6E,
                0x00,  0x00,   0x00,   0x00,   0x00,   0x00,   0x00,  0x00,  0x01,  0x00,  0x01,  0x00,  0x01,  0x00,
                0x61,  0x00,   0x1F,   0x8B,   0x08,   0x08,   0x13,  0xEB,  0x65,  0x3F,  0x00,  0x03,  0x74,  0x65,
                0x6D,  0x70,   0x66,   0x69,   0x6C,   0x65,   0x00,  0x75,  0xCA,  0xC1,  0x0D,  0x80,  0x30,  0x08,

                0x40,  0xD1,   0x3B,   0x09,   0x9B,   0xE0,   0x04,  0x6E,  0x83,  0x0D,  0x10,  0xA0,  0xB4,  0xE9,
                0xA1,  0x71,   0x7C,   0x75,   0x00,   0xFF,   0xF5,  0x7D,  0x84,  0xE3,  0x0B,  0x9B,  0xA8,  0x55,
                0x99,  0x47,   0x8E,   0x19,   0xE9,   0x51,   0xAC,  0xD2,  0xDA,  0x42,  0x40,  0xF8,  0x21,  0x35,
                0xEF,  0x1E,   0x63,   0xCC,   0x4E,   0xC5,   0x72,  0xC9,  0xBD,  0xD5,  0xD8,  0xA3,  0x47,  0x12,
                0x9D,  0xF4,   0xFE,   0xBA,   0x05,   0xE1,   0x01,  0x52,  0xC5,  0x75,  0x16,  0x60,  0x00,  0x00,

                0x00    };  //0x27,   0xC2,   0x23,   0x57 };// в первой строке совпадает*/

/*     data2 = {
                 0x00,	0x01,	0x62,	0x00,	0x00,	0x01,	0x5A,	0x00,	0x53,	0x00,
                 0x00,	0x00,	0xE9,	0x00,	0x32,	0x00,	0x5F,	0x4B,	0x49,	0x30,
                 0x39,	0x38,	0x37,	0x36,	0x2E,	0x50,	0x4F,	0x50,	0x00,	0x00,
                 0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x01,	0x00,	0x01,	0x00,
                 0x01,	0x00,	0x32,	0x00,

                 0x1F,	0x8B,	0x08,	0x08,	0x97,	0x53,   0x9B,	0x3F,	0x00,	0x03,
                 0x74,	0x65,	0x6D,	0x70,	0x66,	0x69,   0x6C,	0x65,	0x00,	0xE3,
                 0xE5,	0x52,	0x80,	0x00,	0x5D,	0x10,   0xE0,	0x0D,	0xF0,	0x0F,
                 0xF0,	0xF7,	0x0F,	0x40,	0x40,	0x5E,   0x2E,	0x5E,	0x2E,	0x4C,
                 0x31,	0x00,	0x07,	0xF7,	0x59,	0xCF,   0x35,	0x00,	0x00,	0x00

     }; //0xE4,	0x50,	0x19,	0x17

    /* data1 = {
             0x00, 0x01, 0x91, 0x00, 0x00, 0x01, 0x89, 0x00, 0x53, 0x00, 0x00, 0x00, 0xE9, 0x00,
             0x61, 0x00, 0x5F, 0x4B, 0x49, 0x30, 0x30, 0x31, 0x30, 0x31, 0x2E, 0x6A, 0x6B, 0x6E,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
             0x61, 0x00, 0x1F, 0x8B, 0x08, 0x08, 0xCF, 0xF1, 0x65, 0x3F, 0x00, 0x03, 0x74, 0x65,
             0x6D, 0x70, 0x66, 0x69, 0x6C, 0x65, 0x00, 0x75, 0xCA, 0xC1, 0x0D, 0x80, 0x30, 0x08,
             0x40, 0xD1, 0x3B, 0x09, 0x9B, 0xE0, 0x04, 0x6E, 0x83, 0x0D, 0x10, 0xA0, 0xB4, 0xE9,
             0xA1, 0x71, 0x7C, 0x75, 0x00, 0xFF, 0xF5, 0x7D, 0x84, 0xE3, 0x0B, 0x9B, 0xA8, 0x55,
             0x99, 0x47, 0x8E, 0x19, 0xE9, 0x51, 0xAC, 0xD2, 0xDA, 0x42, 0x40, 0xF8, 0x21, 0x35,
             0xEF, 0x1E, 0x63, 0xCC, 0x4E, 0xC5, 0x72, 0xC9, 0xBD, 0xD5, 0xD8, 0xA3, 0x47, 0x12,
             0x9D, 0xF4, 0xFE, 0xBA, 0x05, 0xE1, 0x01, 0x52, 0xC5, 0x75, 0x16, 0x60, 0x00, 0x00,
             0x00 // 0xEA, 0xA1, 0xC8, 0x34
      };*/
     data2 = {
        0x00,
        0x01,  //константа
        0x62,
        0x00,   //размер блока
        0x00,
        0x01,   //константа
        0x5A,
        0x00,   //размер всего блока
        0x53,
        0x00,
        0x00,
        0x00,
        0xE9,
        0x00,   //константы
        0x32,
        0x00,   //размер сжатых данных
        0x5F,
        0x4B,
        0x49,
        0x30,
        0x30,
        0x31,
        0x31,
        0x31,
        0x2E,
        0xFF,
        0xFF,
        0xFF,     //имя файла
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x01,
        0x00,
        0x01,
        0x00,      //константы
        0x03,
        0x00,
        0x32,
        0x00,      //размер сжатых данных
        0x1F,
        0x8B,
        0x08,
        0x08,
        0xD6,
        0xD6,
        0x1F,
        0x3F,
        0x00,
        0x03,
        0x74,
        0x65,
        0x6D,
        0x70,
        0x66,
        0x69,
        0x6C,
        0x65,
        0x00,
        0xE3,
        0xE5,
        0xD2,
        0x05,
        0x01,
        0xDE,
        0xFF,
        0xD8,
        0x01,
        0x2F,
        0x17,
        0x2F,
        0x17,
        0x0E,
        0x29,
        0x62,
        0xC0,
        0xA8,
        0x66,
        0xFA,
        0x6A,
        0x06,
        0x00,
        0x88,
        0x7F,
        0x66,
        0x02,
        0xCE,
        0x01,
        0x00,
        0x00,   //сжатые данные gzip
        //CRC
        0x9F,
        0xF0,
        0xCD,
        0x7B,           };

     auto iter = data2.cbegin();

   // std::vector<uint8_t> byte_vec = {0x01, 0xFA, 0x76, 0x73, 0x6D};
            //fromFileUC("dec_bytes4.bin");
    std::cout << "CRC vector size:" << data2.size() << std::endl;
            //conv.toSymbol(inputDataBits, 8);
    crc crc32;
//    crc32.inverse_crc_bit_quads(byte_vec.data(),byte_vec.size(), 32);
    for (int i = 0; i < 44; i++ ){

    crc32.searchCRC(data2.data(), data2.size(),32);
    data2.erase(iter);
    }
   // std::cout << "CRC vector size: " << data.size() << std::endl;
    std::cout << "EndOfCRC" << std::endl;
    return 7;

    //Кодирование
    itpp::Punctured_Convolutional_Code code_punct;
    itpp::ivec G(2);
    G(0) = 0133;
    G(1) = 0171;
    int L = std::max(itpp::int2bits(G(0)), itpp::int2bits(G(1)));
    code_punct.set_generator_polynomials(G, L);
    itpp::bmat punct_matrix = "1; 1";
    code_punct.set_puncture_matrix(punct_matrix);
    itpp::bvec encodedBits = code_punct.encode_trunc(inputBits);
    qDebug() << "Input bits size: " << encodedBits.size();

    //Перемежение
    itpp::bvec to_interleave = encodedBits;
    encodedBits.del(0, encodedBits.size()-1);
    for (unsigned int i = 0; i < 7; i++)
        encodedBits.ins(encodedBits.size(), kvs_interleaver(to_interleave.mid(i*224, 224), 8, 28));

    //Скремблирование
    std::vector<uint8_t> scr_bytes = {0x7A, 0x77, 0x40, 0xD7, 0x74, 0x0D, 0x37, 0x40, 0xD3, 0x79, 0x3D, 0x37, 0x93, 0xAA, 0x79, 0x3A, 0xA4, 0x33, 0xAA, 0x43, 0x9E, 0xA4, 0x39, 0xE9, 0xD3, 0x9E, 0x9D, 0xD0};
    std::vector<uint8_t> scr_seq = conv.toBit(scr_bytes, 8);
    itpp::bvec scrBits = itpp::zeros_b(scr_seq.size());

    for (unsigned int i = 0; i < scr_seq.size(); i++)
        if (scr_seq[i] != 0x00) scrBits[i] = 1;

    for (unsigned int i = 0; i < 7; i++)
        for (unsigned int j = 0; j < 224; j++)
        {
            encodedBits[i*224+j]+=scrBits[j];
        }



    //Повторение
    itpp::bvec infoFrame = encodedBits;
    for (unsigned int i = 0; i < 5; i++)    //повторение информации 6 раз
        infoFrame.ins(infoFrame.size(), encodedBits);
    infoFrame.ins(infoFrame.size(), encodedBits.left(param112.numberOfChannels * 2));

    std::vector<uint8_t> first_symbol = {0x11, 0x64, 0x7F, 0x24, 0x41, 0x4C, 0x55, 0xA4, 0x98, 0x70, 0x74, 0x7C, 0x4F, 0xC1, 0xF6, 0xA2, 0xF6, 0xB0, 0x2F, 0x34, 0x13, 0x47, 0x47, 0x37, 0xB6, 0x0C, 0xEB, 0x35};
    //{0x76, 0x54, 0xF3, 0xD2, 0xBA, 0x6C, 0x7A, 0xE6, 0x32, 0x98, 0xD7, 0x2C, 0xF2, 0x76, 0x2A, 0xC5, 0xB4, 0xF6, 0x26, 0xDB, 0xF2, 0x3D, 0x82, 0x62, 0xA1, 0x0E, 0x35, 0x83};
    std::vector<uint8_t> first_symbol_bits = conv.toBit(first_symbol, 8);
    itpp::bvec first_bits = itpp::zeros_b(first_symbol_bits.size());
    for (unsigned int i = 0; i < first_symbol_bits.size(); i++)
        if (first_symbol_bits[i] != 0x00) first_bits[i] = 1;

    infoFrame.ins(0, first_bits);
//    infoFrame.ins(0, itpp::zeros_b(param112.numberOfChannels * 2));
    qDebug() << "Info frame size: " << infoFrame.size();

    std::vector<uint8_t> infoFrameUC;
    for (int i = 0; i < infoFrame.size(); i++)
    {
        if (infoFrame[i] == 0) infoFrameUC.push_back(0x00);
        else infoFrameUC.push_back(0x01);
    }

    toFile("info.bin", conv.toSymbol(infoFrameUC, 8));

    //searchRepeat(conv.toSymbol(infoFrameUC, 8), 6, 196);

    vector<uint8_t> symbols = conv.toSymbol(infoFrameUC, 2);
/*    searchRepeat(symbols, 6, 98*8);
    std::cout << symbols.size() << std::endl*/;

    b2modulation star;
    star.initialize(2, param112.numberOfChannels);
    vecCF points;

    while((int)symbols.size() >= param112.numberOfChannels){
        vecCF temp;
        vector<uint8_t> symbBlock;
        symbBlock.assign(symbols.begin(), symbols.begin() + param112.numberOfChannels);
        symbols.erase(symbols.begin(), symbols.begin() + param112.numberOfChannels);
        temp = star.modulate(symbBlock);
        for(unsigned int i = 0; i < temp.size(); i++){
            points.push_back(temp[i]);
        }
    }
    qDebug() << "n samples = " << points.size() << endl;


    vecCF toChannel;
    DirectOFDM ofdm;
//    ofdm.initialize(param112);

//    //preamble
//    int first = 18;
//    int step = 16;
//    int num = 8;
//    int numBlocks = 20;
//    for(int i = 0; i < numBlocks; i++){

//        vecCF preamble;
//        preamble = ofdm.preamble(first, step, num);

//        for(unsigned int i = 0; i < preamble.size(); i++){
//            toChannel.push_back(preamble[i]);
//        }
//    }

//    //phase start
//    ofdm.initialize(param56);
//    vector<uint8_t> sequence;
//    for (uint8_t i = 0; i < param56.numberOfChannels; i++)
//        sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x01);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x01);
//    sequence.push_back(0x01);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x00);

//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    sequence.push_back(0x01);
//    sequence.push_back(0x00);
//    sequence.push_back(0x00);
//    for (uint8_t i = 0; i < 10; i++)
//        sequence.insert(sequence.end(),sequence.end() - 5,sequence.end());
//    sequence.push_back(0x01);

//    qDebug() << "Sequence size: " << sequence.size() << endl;

//    //vector<unsigned char> symbols = conv.toSymbol(sequence, 1);
//    star.initialize(1, param56.numberOfChannels);
//    vecCF ps_points;

//    while((int)sequence.size() >= param56.numberOfChannels){
//        vecCF temp;
//        vector<uint8_t> symbBlock;
//        symbBlock.assign(sequence.begin(), sequence.begin() + param56.numberOfChannels);
//        sequence.erase(sequence.begin(), sequence.begin() + param56.numberOfChannels);
//        temp = star.modulate(symbBlock);
//        for(unsigned int i = 0; i < temp.size(); i++){
//            ps_points.push_back(temp[i]);
//        }
//    }
//    //
//    while((int)ps_points.size() >= param56.numberOfChannels){

//        vecCF ofdmSymbol;
//        ofdmSymbol.assign(ps_points.begin(), ps_points.begin() + param56.numberOfChannels);
//        ps_points.erase(ps_points.begin(), ps_points.begin() + param56.numberOfChannels);

//        vecCF mod;
//        mod = ofdm.modTest(ofdmSymbol);

//        for(unsigned int i = 0; i < mod.size(); i++){
//            toChannel.push_back(mod[i]);
//        }
//    }

    //information block
    ofdm.initialize(param112);
    while((int)points.size() >= param112.numberOfChannels){

        vecCF ofdmSymbol;
        ofdmSymbol.assign(points.begin(), points.begin() + param112.numberOfChannels);
        points.erase(points.begin(), points.begin() + param112.numberOfChannels);

        vecCF mod;
        mod = ofdm.modTest(ofdmSymbol);

        for(unsigned int i = 0; i < mod.size(); i++){
            toChannel.push_back(mod[i]);
        }
    }

    qDebug() << "mod size = " << toChannel.size() << endl;

    //convert to q15 and q31
    std::vector<std::complex <int16_t>> c16Channel;
    std::vector<int32_t> c32Channel;
    if ((int)toChannel.size() == 75*param112.ofdmLength) c32Channel.resize(toChannel.size());
    //else {std::cout << "Error. Invalid signal duration." << std::endl;   return -1;}
    toChannel = Normalize(toChannel);
    for (unsigned int i = 0; i < toChannel.size(); i++){
        c16Channel.push_back(std::complex<int16_t>((int16_t)((toChannel.at(i).real())*INT16_MAX*0.8), (int16_t)((toChannel.at(i).imag())*INT16_MAX*0.8)));
        c32Channel.push_back((int32_t)((toChannel.at(i).real())*INT32_MAX*0.8));
    }

    qDebug() << "c32Channel size = " << c32Channel.size() << endl;

    //outSignalBuffer.push(c32Channel);

   
